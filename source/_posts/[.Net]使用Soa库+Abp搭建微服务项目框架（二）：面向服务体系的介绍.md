---
thumbnail: >-
  images/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p6X5pmTbHg=,size_20,color_FFFFFF,t_70,g_se,x_16
title: '[.Net]使用Soa库+Abp搭建微服务项目框架（二）：面向服务体系的介绍'
excerpt: >-
  上一章我们建立了一个典型的面向领域设计的Abp小项目，如果按照常规的开发方式，会遇到什么问题呢？先来完善一下这个小项目，在定义好各实体类后，运行Miguration并向数据库里写入一些初始数据。现在整个项目的依赖引用图如下，每一个都有独立的引用路线，互不干涉。简略图如下假设现在有一个需求，MainService业务需要用到Service1和Service2
  中的数据，如何操作？在使用Abp框架时，传统开发方式是先建立领域层服务，应用层中调用领域层服务（Manager）并返回给UI
tags:
  - .net
  - EFCore
  - 数据库
categories:
  - .NET
toc: true
recommend: 1
keywords: categories-java
uniqueId: '2022-01-15 10:11:00/[.Net]使用Soa库+Abp搭建微服务项目框架（二）：面向服务体系的介绍.html'
abbrlink: adffad43
date: 2022-01-15 10:11:00
cover:
description:
---
<p><span data-cke-copybin-start="1"><span data-cke-copybin-start="1">​</span></span></p><p>上一章我们建立了一个典型的面向领域设计的Abp小项目，如果按照常规的开发方式，会遇到什么问题呢？</p><p>先来完善一下这个小项目，在定义好各实体类后，运行Miguration并向数据库里写入一些初始数据。</p><p><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected" data-cke-display-name="图像" data-cke-filter="off" data-cke-widget-id="10" data-cke-widget-wrapper="1"><img alt="" class="cke_widget_element" data-cke-saved-src="https://img-blog.csdnimg.cn/d2ffdfe5a83844a5a8980f246585e69d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p6X5pmTbHg=,size_20,color_FFFFFF,t_70,g_se,x_16" data-cke-widget-data="%7B%22hasCaption%22%3Afalse%2C%22src%22%3A%22https%3A%2F%2Fimg-blog.csdnimg.cn%2Fd2ffdfe5a83844a5a8980f246585e69d.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZHJvaWRzYW5zZmFsbGJhY2s%2Cshadow_50%2Ctext_Q1NETiBA5p6X5pmTbHg%3D%2Csize_20%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16%22%2C%22alt%22%3A%22%22%2C%22width%22%3A%22557%22%2C%22height%22%3A%22188%22%2C%22lock%22%3Atrue%2C%22align%22%3A%22none%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="image" height="188" src="d2ffdfe5a83844a5a8980f246585e69d.png" width="557"/></span></p><p>现在整个项目的依赖引用图如下，每一个都有独立的引用路线，互不干涉。</p><p><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected" data-cke-display-name="图像" data-cke-filter="off" data-cke-widget-id="9" data-cke-widget-wrapper="1"><img alt="" class="cke_widget_element" data-cke-saved-src="https://img-blog.csdnimg.cn/7adff0f3eff5415ea76024580a953546.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p6X5pmTbHg=,size_20,color_FFFFFF,t_70,g_se,x_16" data-cke-widget-data="%7B%22hasCaption%22%3Afalse%2C%22src%22%3A%22https%3A%2F%2Fimg-blog.csdnimg.cn%2F7adff0f3eff5415ea76024580a953546.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZHJvaWRzYW5zZmFsbGJhY2s%2Cshadow_50%2Ctext_Q1NETiBA5p6X5pmTbHg%3D%2Csize_20%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16%22%2C%22alt%22%3A%22%22%2C%22width%22%3A%221036%22%2C%22height%22%3A%22464%22%2C%22lock%22%3Atrue%2C%22align%22%3A%22none%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="image" height="464" src="7adff0f3eff5415ea76024580a953546.png" width="1036"/></span></p><p>简略图如下</p><p><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected" data-cke-display-name="图像" data-cke-filter="off" data-cke-widget-id="8" data-cke-widget-wrapper="1"><img alt="" class="cke_widget_element" data-cke-saved-src="https://img-blog.csdnimg.cn/c0742176184a46938928335b163a6d76.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p6X5pmTbHg=,size_20,color_FFFFFF,t_70,g_se,x_16" data-cke-widget-data="%7B%22hasCaption%22%3Afalse%2C%22src%22%3A%22https%3A%2F%2Fimg-blog.csdnimg.cn%2Fc0742176184a46938928335b163a6d76.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZHJvaWRzYW5zZmFsbGJhY2s%2Cshadow_50%2Ctext_Q1NETiBA5p6X5pmTbHg%3D%2Csize_20%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16%22%2C%22alt%22%3A%22%22%2C%22width%22%3A%221107%22%2C%22height%22%3A%22683%22%2C%22lock%22%3Atrue%2C%22align%22%3A%22none%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="image" height="683" src="c0742176184a46938928335b163a6d76.png" width="1107"/></span></p><p>在使用Abp框架时，传统开发方式是先建立领域层服务，应用层中调用领域层服务（Manager）并返回给UI层，完成整个业务流程；或者更简单方式是直接在应用层注入仓储对象，拿到实体类做数据操作。</p><p>我们分别来完成这两个方式实现这一需求。</p><p>首先在MatoProject.MainService.Application项目中建立一个应用层服务MainService.cs并继承AsyncCrudAppService。</p><p>建立一个方法GetExtends，用于查询Entity1，Entity2 中的Type和Num字段。</p><p> 方式1: 模拟传统方式在应用层获取数据：</p><p><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected" data-cke-display-name="图像" data-cke-filter="off" data-cke-widget-id="7" data-cke-widget-wrapper="1"><img alt="" class="cke_widget_element" data-cke-saved-src="https://img-blog.csdnimg.cn/f44fdaef844443bcb783617af123de6c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p6X5pmTbHg=,size_20,color_FFFFFF,t_70,g_se,x_16" data-cke-widget-data="%7B%22hasCaption%22%3Afalse%2C%22src%22%3A%22https%3A%2F%2Fimg-blog.csdnimg.cn%2Ff44fdaef844443bcb783617af123de6c.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZHJvaWRzYW5zZmFsbGJhY2s%2Cshadow_50%2Ctext_Q1NETiBA5p6X5pmTbHg%3D%2Csize_20%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16%22%2C%22alt%22%3A%22%22%2C%22width%22%3A%22708%22%2C%22height%22%3A%22210%22%2C%22lock%22%3Atrue%2C%22align%22%3A%22none%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="image" height="210" src="f44fdaef844443bcb783617af123de6c.png" width="708"/></span></p><p>看看依赖情况：</p><p><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected" data-cke-display-name="图像" data-cke-filter="off" data-cke-widget-id="6" data-cke-widget-wrapper="1"><img alt="" class="cke_widget_element" data-cke-saved-src="https://img-blog.csdnimg.cn/ab0588ed7e35402c8daa9d33ed6687b7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p6X5pmTbHg=,size_20,color_FFFFFF,t_70,g_se,x_16" data-cke-widget-data="%7B%22hasCaption%22%3Afalse%2C%22src%22%3A%22https%3A%2F%2Fimg-blog.csdnimg.cn%2Fab0588ed7e35402c8daa9d33ed6687b7.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZHJvaWRzYW5zZmFsbGJhY2s%2Cshadow_50%2Ctext_Q1NETiBA5p6X5pmTbHg%3D%2Csize_20%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16%22%2C%22alt%22%3A%22%22%2C%22width%22%3A%22720%22%2C%22height%22%3A%22125%22%2C%22lock%22%3Atrue%2C%22align%22%3A%22none%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="image" height="125" src="ab0588ed7e35402c8daa9d33ed6687b7.png" width="720"/></span></p><p> 若是使用方式1， 在注入仓储对象的时候，势必直接引用了这两个服务的领域层，造成了耦合。</p><p>方式2: 模拟传统方式在领域层获取数据：</p><p>在Domain层中分别建立两个领域服务（Manager），并且定义GetType和GetNum方法，分别用于获取Entity1，Entity2 中的Type和Num字段</p><p><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected" data-cke-display-name="图像" data-cke-filter="off" data-cke-widget-id="5" data-cke-widget-wrapper="1"><img alt="" class="cke_widget_element" data-cke-saved-src="https://img-blog.csdnimg.cn/0b5915e9c1674f97ab939cf51784939d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p6X5pmTbHg=,size_20,color_FFFFFF,t_70,g_se,x_16" data-cke-widget-data="%7B%22hasCaption%22%3Afalse%2C%22src%22%3A%22https%3A%2F%2Fimg-blog.csdnimg.cn%2F0b5915e9c1674f97ab939cf51784939d.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZHJvaWRzYW5zZmFsbGJhY2s%2Cshadow_50%2Ctext_Q1NETiBA5p6X5pmTbHg%3D%2Csize_20%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16%22%2C%22alt%22%3A%22%22%2C%22width%22%3A%22644%22%2C%22height%22%3A%22293%22%2C%22lock%22%3Atrue%2C%22align%22%3A%22none%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="image" height="293" src="0b5915e9c1674f97ab939cf51784939d.png" width="644"/></span></p><p><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected" data-cke-display-name="图像" data-cke-filter="off" data-cke-widget-id="4" data-cke-widget-wrapper="1"><img alt="" class="cke_widget_element" data-cke-saved-src="https://img-blog.csdnimg.cn/377c109307a9416cb8318327cc69805f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p6X5pmTbHg=,size_20,color_FFFFFF,t_70,g_se,x_16" data-cke-widget-data="%7B%22hasCaption%22%3Afalse%2C%22src%22%3A%22https%3A%2F%2Fimg-blog.csdnimg.cn%2F377c109307a9416cb8318327cc69805f.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZHJvaWRzYW5zZmFsbGJhY2s%2Cshadow_50%2Ctext_Q1NETiBA5p6X5pmTbHg%3D%2Csize_20%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16%22%2C%22alt%22%3A%22%22%2C%22width%22%3A%22654%22%2C%22height%22%3A%22301%22%2C%22lock%22%3Atrue%2C%22align%22%3A%22none%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="image" height="301" src="377c109307a9416cb8318327cc69805f.png" width="654"/></span></p><p> 在MainService.cs的GetExtends方法更改分别调用两个Manager 的GetType与GetNum方法，从中获取Type和Num值。</p><p>拼接完成后返回结果<span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected" data-cke-display-name="图像" data-cke-filter="off" data-cke-widget-id="3" data-cke-widget-wrapper="1"><img alt="" class="cke_widget_element" data-cke-saved-src="https://img-blog.csdnimg.cn/4c5f520f42804b5783fd7f4e5554a38b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p6X5pmTbHg=,size_20,color_FFFFFF,t_70,g_se,x_16" data-cke-widget-data="%7B%22hasCaption%22%3Afalse%2C%22src%22%3A%22https%3A%2F%2Fimg-blog.csdnimg.cn%2F4c5f520f42804b5783fd7f4e5554a38b.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZHJvaWRzYW5zZmFsbGJhY2s%2Cshadow_50%2Ctext_Q1NETiBA5p6X5pmTbHg%3D%2Csize_20%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16%22%2C%22alt%22%3A%22%22%2C%22width%22%3A%22707%22%2C%22height%22%3A%22204%22%2C%22lock%22%3Atrue%2C%22align%22%3A%22none%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="image" height="204" src="4c5f520f42804b5783fd7f4e5554a38b.png" width="707"/></span></p><p> 看看依赖情况：</p><p><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected" data-cke-display-name="图像" data-cke-filter="off" data-cke-widget-id="2" data-cke-widget-wrapper="1"><img alt="" class="cke_widget_element" data-cke-saved-src="https://img-blog.csdnimg.cn/363af034d9b64a3f94ecb9b0e81f76c4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p6X5pmTbHg=,size_20,color_FFFFFF,t_70,g_se,x_16" data-cke-widget-data="%7B%22hasCaption%22%3Afalse%2C%22src%22%3A%22https%3A%2F%2Fimg-blog.csdnimg.cn%2F363af034d9b64a3f94ecb9b0e81f76c4.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZHJvaWRzYW5zZmFsbGJhY2s%2Cshadow_50%2Ctext_Q1NETiBA5p6X5pmTbHg%3D%2Csize_20%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16%22%2C%22alt%22%3A%22%22%2C%22width%22%3A%22776%22%2C%22height%22%3A%22238%22%2C%22lock%22%3Atrue%2C%22align%22%3A%22none%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="image" height="238" src="363af034d9b64a3f94ecb9b0e81f76c4.png" width="776"/></span></p><p>  若是使用方式2， 在注入领域服务（Manager）时，也势必直接引用了这两个服务的领域层，造成了项目之间的耦合</p><p>若是在MainService服务层应用了Service1 和 Service2 的话，则项目的各个模块边界将变得不明晰，上一章所讨论的依据上下文边界划分服务，也将变得没有意义。</p><p><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected" data-cke-display-name="图像" data-cke-filter="off" data-cke-widget-id="1" data-cke-widget-wrapper="1"><img alt="" class="cke_widget_element" data-cke-saved-src="https://img-blog.csdnimg.cn/4a3bcf48361342dea9af1de5bf887616.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p6X5pmTbHg=,size_20,color_FFFFFF,t_70,g_se,x_16" data-cke-widget-data="%7B%22hasCaption%22%3Afalse%2C%22src%22%3A%22https%3A%2F%2Fimg-blog.csdnimg.cn%2F4a3bcf48361342dea9af1de5bf887616.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZHJvaWRzYW5zZmFsbGJhY2s%2Cshadow_50%2Ctext_Q1NETiBA5p6X5pmTbHg%3D%2Csize_20%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16%22%2C%22alt%22%3A%22%22%2C%22width%22%3A%221176%22%2C%22height%22%3A%22750%22%2C%22lock%22%3Atrue%2C%22align%22%3A%22none%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="image" height="750" src="4a3bcf48361342dea9af1de5bf887616.png" width="1176"/></span></p><p>简略图如下 </p><p><span class="cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected" data-cke-display-name="图像" data-cke-filter="off" data-cke-widget-id="0" data-cke-widget-wrapper="1"><img alt="" class="cke_widget_element" data-cke-saved-src="https://img-blog.csdnimg.cn/472adebfde0e4f529be880398037a526.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p6X5pmTbHg=,size_20,color_FFFFFF,t_70,g_se,x_16" data-cke-widget-data="%7B%22hasCaption%22%3Afalse%2C%22src%22%3A%22https%3A%2F%2Fimg-blog.csdnimg.cn%2F472adebfde0e4f529be880398037a526.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZHJvaWRzYW5zZmFsbGJhY2s%2Cshadow_50%2Ctext_Q1NETiBA5p6X5pmTbHg%3D%2Csize_20%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16%22%2C%22alt%22%3A%22%22%2C%22width%22%3A%221115%22%2C%22height%22%3A%22692%22%2C%22lock%22%3Atrue%2C%22align%22%3A%22none%22%2C%22classes%22%3Anull%7D" data-cke-widget-keep-attr="0" data-cke-widget-upcasted="1" data-widget="image" height="692" src="472adebfde0e4f529be880398037a526.png" width="1115"/></span></p><p> 现在，我们需要考虑用面向服务体系的架构改造，将MainService，Service1， Service2 解耦。</p><p>若要独立成服务，则要考虑引用其抽象，也就是要做接口化的改造，使其之间的状态变为弱关联</p><p>下一章节将介绍如何结合Abp，进行接口化改造</p><p><span data-cke-copybin-start="1"><span data-cke-copybin-end="1">​</span></span></p>